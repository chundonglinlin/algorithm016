/*
 * =====================================================================================
 *
 *       Filename:  20201103-62-uniquePaths.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2020/11/03 23时46分43秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdlib.h>
int uniquePaths(int m, int n){
    // 状态转移方程
    int dp[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 || j == 0) {     //最上一行或者最左一列
                dp[i][j] = 1;
            } else {
                /*
                dp[i][j]的值就是第 i 行第 j 列这个格子的上面那个格子的值加上左边那个格子的值，
                也就是dp[i][j] = dp[i-1][j] + dp[i][j-1]，
                因为这两个格子都可以走到dp[i][j]这个格子，那么他们的路径数之和就是dp[i][j]的值。
                状态转移方程是dp[i][j] = dp[i-1][j] + dp[i][j-1]，
                当 i == 0 或者 j == 0 的时候无外乎就是最上一行或者最左一列，我们在最上一行的路径数只能是一条（因为只能一直往左走），
                所以 dp[0][j]的值全为 1，同理最左一列的值也是1（因为只能一直往下走），
                其余的值按照状态转移方程就可以填满了，最后返回最右下角的值（dp[n-1][m-1]）就可以了。
                */
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    
    return dp[n-1][m-1];
}
